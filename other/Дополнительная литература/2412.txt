В первую очередь на материал лекции. Кто пользуется старыми лекциями несколько поколениями студентов, которые были выожены, это не секрет. Поймите, что чтение лекции - дело живое.
Никогда не возможно выполнять по строгому шаблону. Представление этой информации может отличаться. По тупикам примеров не было в предыдущие годы. Сегодня рассмотрим материал по восстановлении работоспособности  системы.

Будет материал по (??)

Будет единым блоком. По сути изложен другой материал.
На прошлой лекции рассмотрели подробно алгоритм 
рзавитие алгоритма дейкстры. Алгоритм банкира.
Рассмотрели обнаружение тупиков  - модель
Двудольный направленный граф.

Подмножество вершин.

Матрицы запросов или распрделений
На матрице рассматриваются предлагаемые подходы.


ПАМАГИТЕ

~10 
Перезагрузка (?)

Дорогое решение, так как будет потеряна вся проделанная незавершившимися процессами работа.

Для системы, работающей длительное время, такой подход невозмоен

1) Последовательно завершать процессы, попавшие в тупик

В результате, процессы, работа которых завершается, вернут занимаемые ресурсы. Этих ресурсов мб достаточно, чтобы другие процессы могли продолжить работу.
Очевидный недостаток - проделанная работа завершаемого процесса будет потеряна.

2) Завершать процессы, не имеющие отношения к тупику - отнимать ресурсы у процессов, вернуть их системе, и мб того процессы, попавшие в тупик, смогут завершиться.

Решается на основе приоритетов. 

На этом материал по тупикам закончен.
--------------------------------
Тупики все
--------------------------------

15:30 Начнем с виртуальной машины. 
История. Че вообще было.

Сегодня ВМ - развитие той самой идеи.
Сначала исторически былт разработаны ОС мультипрограмной пакетной обработки, с появлением средств позволяющих пользователю взаимо с системой
Такие средства как мониторы. которые оперативно позволяли получать информацию о выполняемых программах.
Клавиатура, которая позволяла посылать команды управляющие выполнением программы.
В IBM система разделения времени, которая была написана ими называлась TSS/360.
Очень медленная и громоздкая. От нее сразу отказались. В это же время группой из IBM в кембридже разрабатывалась система разделения времени. Называлась она CP/CMS
Позже переименовали в VM/370
Тут появилась абривеатура Virtual Machine/
понятие виртуальная машина появилась в середине 70 годов прошлого века в разработках IBM.
Чтобы проще понять саму идею VM, нарисуем схему.

Виртуальные 370
|____|____|____|____|
|CMS | CMS|CMS | CMS|
|_____VM/370

Идея вирт машины - в коде ядра реализована такая система как задача запускать другие операционные системы.

---- ЧАСТЬ 2 ------

IBM 360 - третье поколение машин
Можно было создать систему разделения времени
Но разработанная система TSS/360 не оправдала надежд
IBM создавла много групп, CP/CMS -> VM/360

VM/370 позволяла как отдельные процессы запускать ОСИ. Одновременною

Режим V86

Режим в котором как задачи запускаются ОСи реального режема. Плная кореалиция с VM 360 (&)

V86 - операционные системы реальнго режима в виртуальном режиме.

Безусловно надо еще раз поговорить, что такое виртуальная машина.
Виртулаьная машина - кажущаяся. Любая ОС, установленнаая на голое железо, предоставляет совсем другие возможности.
Мы можем поставить разные ОСи. 

ЧЕГО?

Вы в свое распоряжение получаете совсем другую виртуальную машину.
Если линух поставили - линух машина.

Существует целый набор виртуальных машин. Серьезные программы, которые дают пользователю в распоряжение виртуальное железо, на которое можно сттавить другую ОС.
DOSBox, VMWare, VirtualBOX и прочее

Иерхическая машина 

В своей книге IBM 360 изложили идею такой машины.

На схеме изображена структура системы
Над ядром есть еще несколько уровней
12:40 картиночка
Медник-Донованн
Ничего не видно

Структура ядра системы:
    Программное обеспечение ставится на голое железо, на аппаратную часть!!!
	* нижний уровень -  аппаратная часть
	* уровень 1 - управление процессорами (нижний уровень, т.е. Диспетчеризация - выделение процессу процессорного времени); 
	* уровень 2 - ((P, V) - семафорные операции, контр. доступа к разд. рес), планировщик процессов (операция более выс. уровня. Постановка процессов вочередь к процессору или другим ресурсам), управление памятью; Процессор, оперативка, вн.устр - аппаратные устройства
	* уровень 3 - управление процессорами (верхний уровень -- создание и удаление процессов. Система принимает решение об этом, более высокоур. операция);
	* уровень 4  - управление устройствами (подсистема ввода / вывода);
	* уровень 5 - управление информацией (файловая система). Система предоставляет такие средства как наименование файлов,  построения дерева катологов, удобных для пользователя.
УУУУУ ШАКАЛЬНАЯ КАРТИНКА
(на более высоких уровнях находятся пользовательские процессы, которые запускаются в системе из командной строки или могут пользоваться другими высокоуровневыми процессами для своего запуска.)
Эта структура определеяет содерджание монолитных ядер.
https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BD%D0%BE%D0%BB%D0%B8%D1%82%D0%BD%D0%BE%D0%B5_%D1%8F%D0%B4%D1%80%D0%BE
Все процессы обращаются к рес. ядра и вместе исп. ресурсы системы
Каждый низлежащий уровень может обращаться только к следущему уровню. Необходимо осущ. монопольный доступ. 

Файловая система будет рабоает с внешними устройствами через подсистему ввода-вывода

33:00
Структура ядра операционной системы UNIX BSD 4.4
На самом нижнем уровне нах аппаратура. 
Непосредственно над аппаратной частью находятся коды операционной системы, которые непосредственно взаимодействуют с аппаратной частью

Мы здесь видим драйвер устройств.
В системе устройства бывают только двух типов - символьные и блочные

Драйверы на делятся на сивмольные драйверных устройств и блочных устройств. (+ драйверы сетевых устройств)

Диспетчеризация снизу справа.

Кроме символьных и блочных устройств появились сетевые драйверы (драйверы сетевых устройств)

Выноска - необработанный teletype телетайп
Дисциплины??? линии связи
|
V
Обработанный телетайп

Буферный кэш справа от диспетчеризпции
страничный кеш рядом в том же блоке
Правее - Маршрутизация для сетевых устройств

Еще правее - полная кореляция - планирование процессов
(более высокоуровневая сем диспетчеризация)

Буферный кеш связан с файловой системой
(файловая система поавее)

(так же правее че ФС)
Страничный кеш связан с виртуальной памятью

Правее еще!
Сетевые протоколы

Сокеты над сетевым протоколом 

МАКСИМУМ ПРАВЫЙ ( более высокий уровень)
Создание и завершение процессов, здесь находится обработка сигналов

(есть норм. фото этой таблицы в беседе)

Управление терминалами 

	1. символьный уровень ->
	1.  именование файлов
	1. отображение адреса ->
4. страничное прерывание
.....................
Зачем я существую
Why are we still here?
Страдать.
Just to suffer
.......................

Картиночка 
Заштрих. области - аппаратные прерывания

Без штриха - системные вызовы.


Иерархическая машина Медника-Донованна
по принципу близости функций к аппаратной части
Функц. драйверы находятся ниже. (Краткое изложение всего что было выше)

Вся передача осуществляется через буфера

Исторически важным для UNIX важно понятие teletype
Использовался для разработки системы UNIX
Части кода для управления телетайпом никуда не делись из UNIX
Стивен Раго (сл. семестр)
Самые запутанные коды в UNIX связана с ТТ
На более высоком уровне упр ТТ перех в упр. терминалами. 

В части, связ. с проуессами видно полную корреляцию с машиной МД
Для хранения информации исп. энергонезависимые устройства, все адресное пр-во жесткого диска делятся на 2 части диска. Большая упр. файловая система (драйвер ЖД), но чтобы иметь возможность пользоваться этими файлами, их надо отрисовать, система предоставляет символьные наименование

Имя файла в unix не явл. идентификатором, только inode!

Как видите, и жта иерархическая схема аккумулирует всю рассмотренную информацию, но сокеты и ф. система будут рассмотренна в сл. семестре

Хочу подчеркнуть связь этих двух схем, мололитные ядра, иерархические схемы...

55:00
Архитектура ядер ОС
(Монолитные и микроядра)
Если собрать всю информацию и проанализировать ее, то сущ. два вида ядер - монолитное и микроядро. Остальные названия подчеркивают большую минимизация. Основная идея выражается понятием микроядра.

Монолитное ядро - monolitic kernel
Такая структура ядра ос, про которой все его компоненты явл. модулем одной программы. Все к. используют
вз-ют путем вызова процедур. Единое адресное пространства

В противоположность в микроядре часть функций вынесена из ядра в другие программы, которые могут выполняться в собственных адр. пространствах

Все ос семейства Win Unix - системы с монолитными ядрами. Не смогли сделать микроядра  в Windows XP :(
    Соломон_Русинович для подробной инфы (Является ли Windows XP ОС с микроядерной архитектурой)
    
Все функции, которые изображены на таблице реализованны в ядре и такое ядро называется монолитным. Структура, содержит ссылки на другие структуры. Программа, состоящая из подпрограмм - монолитное ядро. Одни подпрограммы могут вызывать другие. Современные монолитные ядра многопоточные - каждый зап. драйвер - отд. поток. Windows - ООП. Unix, Linux - классический подход (Таненбаум сравнивает эти ос)

66:00
Важнейшей для работы систем с монолитным ядром является система прерываний. В нее входят: 
	1. системные вызовы часто исп. термин API, функции, которые может запросить пользователь у системы, 
	1. исключения, аварийные ситуации в системе (исправимые - page fault, неисправимые) 
	1. аппаратные прерывания - ассинхронное событие, пред. 2 - синхронные. Предназначены для информирования процессора об окончании операции ввода-вывода.

Реализованна идея распараллеливания функций - вн. устройствами упр. не процессор. Канальные, шинные - контроллеры. Команды от процессора переводят контроллер в нужный режим. В результате нажатия клавиши она поступает в буфер клавиатуры, для этого необходимо проинформировать процессор и он запустит нужный обработчик прерывания. 
    
Книга Шоу -- Логическое проектирование ОС.

75:00
Давайте посмотрим подробно всю последовательность действий в системе при запросе системы на ввод/вывод:
    Приложение никогда не должно уметь обращаться напрямую к внешним устройствам, иначе оно бы смогло изменять код ОС и такую ОС невозможно было бы защитить. В операционной системе read/write главные системные вызовы. Чем код меньше и яснее - тем он лучше.
Приложение                            | Ядро
---------------------------------------------------------------
Запрос ввода-вывода       |
                                                        | SVC - supervisor call, код операционной системы в стадии выполнения, переход в ядро штрих  - передаются данные  ->
	                                                | Подсистема вызовет драйвер соотв. устройства, данные будут переданы в формат, понятном драйверу -> передаются данные
                                                        | StartIO 
                                                        | По завершении операции ввода-вывода формируется сигнал, поступающий на PIC <- прерывание                       
                                                        | Interrupt Handler - процессор информируется об окончании операции ввода-вывода. Процессор, используя IDT, вызвал этот обработчик. Обр. получил данные, в результате его работы будут сформированны данные, пост. от прерывания, затем будет вызвана часть драйвера, которая передает информацию приложению. Read - код символа, write - информация об успехе/неуспехе вывода.
                                                        |
  После того, как процесс выведен из состояния сна - данные записываются из буфере ядра. куда были записаны соотв. обработчиком прерывания.                                                      
							    |
выполняются разные части кода монолитного ядра операционной системе. Данный тип ввода-вывода, когда процесс блокируется (приложение, uninterruptable sleep), синхронный-блокирующий.

В опрационных системах стремятся сократить время работы приложений. Такой тип ввода-вывода тормозит приложения. Также сущ. команды асинхронного ввода-вывода.

При таком построении ядра (unix bsd), существует два уровня взаимодействия ос - прозрачный и непрозрачный уровень. 
Между ними определен интерфейс - ф-ия, которая может вызывать другие (функции) уровни, что позволяет сократить скорость разработки. 

Непрозрачный интерфейс - каждый уровень ос может обратиться только к след. уровню.
Прозрачный интерфейс -(противоположно прошлому) возможно обращение ко всем уровням

100:00
Микроядро
Отдельные составляющие такой ос могут выполняться в собственных адресных пространствах. 

Первая ос с микроядром была названа Mach. первыми реализовали идею микроядерной архитектуры. 

unix, linux явл. минимизированными, графика вынесена из ядра.

Вся микроядерная архитектура построена по принципу клиент-сервер
(подпрограммы) Рассматриваются в системе как серверы
Приложения обращаются к соотв. серверам
Сервера отвечают сообщениями. 
Во главу угла встает надежная передача сообщений. Взаимодействие идет по строгим протоколам. В них важнейшей составляющей является 

Диаграмма: три состояния блокировки процесса при передаче сообщения (забл. при посылке, ответе, приеме). Это влияет на отзывчивость, скорость работы такой системы.
































































